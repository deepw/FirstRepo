1. Think about these solutions:
a. Can you use bitmasks ?
b. Can you use sorting ? If you are trying to search something in a sorted array, see if binary search applies. 
c. For "rotated string" type problems, see if s1+s1 helps in some way. Eg. 1.8. 

Some tips:
- When listing all the data structures that you could use to solve a problem or find a more efficient way to solve it, think of all data structures possible. BST, MinHeap, MaxHeap, Hashmap, Stack. Simplifying a unix path is a typical example where you could use a stack to simplify the solution. If you see a . ignore, .. pop, else push. at the end construct the path with whatever is left in the stack. 
- When dealing with 2D arrays, always easier to just work off of pointers. Check eg. 1.6. 
- For tree question, try to see apply patterns of: preorder traversal, BFS/DFS traversals etc. Eg. Find if T2 is a subtree of T1. Recursively walk two trees to check if they are identical. For each child of root, check if the subtree is same as root.  You could also generate inorder+preorder of both trees and then check if the subtree is a substring of both the orders. 
- Print all subsets of a set [also called the Power set]. Reduce the problem to print all integers from 0 to 2^n. If ith bit is set, that index i is a part of the subset.      
for(counter = 0; counter < pow_set_size; counter++)
    { for(j = 0; j < set_size; j++)
       {
          if(counter & (1<<j))
            printf("%c", set[j]);
       }
       printf("\n");
    }
- For some questions you can use the fact that calling something "integers" implies a finite range of 32 bits. [-INT_MAX, INT_MAX]
- To read the last k of a file/stream etc, you can use a circular array by filling in using arr[count%k], count++.
- Use the fact that negative integers have MSB 1. ((n >> 31) & 0x1 == 1)
- Selection Rank Algorithm - to find the kth smallest/largest number in an array. It goes like this:
	1. Pick a pivot, an integer arr[i] at any location i in the array. 
	2. Now move all elements greater that arr[i] to the right of i and all smaller to left of i. 
	3. Now, if i==k, then just find the smallest element on the right side to find the kth biggest element. 
	4. if i > k, repeat for the right side, otherwise repeat for the left side.
	5. This can be extended to find k biggest numbers also.  
- To pass a 2D array bar[][] use foo ((int*)matrix) and then define foo as void foo(int * 2D, m, n) { *((2D+i*m)+n)}  
- Whenever a sorted array is provided, apply binary search. Eg. rotated sorted array, find a range in which an integer exists etc. Also to find sqrt of a number. http://www.programcreek.com/2014/06/leetcode-search-in-rotated-sorted-array-java/
- To find k largest elements in an array, you can bubble k items to the right. [O(n.k)]
- Given an index n from a 2D matrix, row=n/C and column=n%C. Useful to binary search from a sorted 2D array. See search_matrix.c.
- Whenever you need to traverse the tree to mark nodes visited, think DFS/BFS. Most of the times any one of the traversal algos will work. DFS is easier, just recurse for all neighbors and keep visited array around. http://www.geeksforgeeks.org/find-number-of-islands/
- LRU Implementation: Use a hash table to keep frame entries pointing to nodes in a doubly linked list. DLL keeps the LRU at the end of the queue by moving the used node at the front of the list. 
- A lot of linked list questions are solved using slow, fast pointers. nth element from the end, cycle in a linked list etc.
- To print nodes of a tree with one level on a line, use a nodecount to keep the current size of the queue and print on one line till this nodecount >0. Check out: http://geeksquiz.com/print-level-order-traversal-line-line/
- For most of such problems you create a list for each level or horizontal distance while walking the tree using BFS. Once done print all the lists seperately.  
- Validate a binary tree: 1. check root against INTMAX and -INTMAX, root->left with -MAX, root->value and root->right with root->value and MAX and so on. You can also use inorder traversal and check each prev element is less than the current. 
- Use BFS for questions where top down approach might result in a more optimal solution, like minimum depth of a binary tree. You know the min depth the first time you hit a leaf. 
- A lot of questions need to track the level of a tree. Use a size of queue parameter which keeps the size of the queue at each level. Like: http://www.programcreek.com/2014/04/leetcode-binary-tree-right-side-view-java/
- Nearly sorted array is an interesting question. For a k sorted array, use a min heap of size k+1; 
- To find intersection of two linked lists, find d=n1-n2, walk the longer list d times, from here on both lists have the same number of nodes. Just walk the two lists and find the common node. 
- To get the kth biggest element from a BST, you can actually do a reverse in-order traversal. right, root, left and then count nodes, print the kth node. 
- Detecing a cycle is easier with running two pointers, slow and fast. Using this you find a node inside the cycle. mark it p2.  Now to remove the cycle, you can set p1 to start from head. For every ptr1, circle the whole cycle and check if p2->next == p1. set p2->next = NULL to remove this cycle. 
- Dutch National Flag Problem: Given an array with numbers only 0, 1, 2 it can be sorted in O(n) time. Use this algorithm. 
l=0, m=0, h=N-1;
while (mid<=hi) { switch (mid) { case 0: swap a[mid] a[low] low++; mid++; case 1: mid++; case 2: swap (a[mid] and a[high])high--;
- Shuffle Cards: swap i with random positions where i goes from n-1 to 0. 
- Check out the DP for two egg find floors problem. For n eggs and k floors: eggDrop(n, k) = 1 + min{max(eggDrop(n - 1, x - 1), eggDrop(n, k - x)): x in {1, 2, ..., k}} http://www.geeksforgeeks.org/dynamic-programming-set-11-egg-dropping-puzzle/
- Benefits of Quick Sort: 1. randomized version does not produce worst case in a known pattern. So average is O(NlgN). 2. No extra space is required. 3. Uses tail-recursion (where recursion is the last statement of the function so the compiler does not have any state to keep. 
- Sorting a linked list with 0s and 1s. set a pointer at tail, now if tmp->val is 1 move it to the end of the list. 
- Always consider palindromes of length 1 [all single characters] of length 2 [aa or bb] and then more than 2 (aba, cbc). 
- Always think of BFS if you are looking for shortest path to the leaf. Whenenver you decide to use DFS, check if you need bfs instead. For BFS you need a queue, for DFS just recursion is sufficient. 
- Topological sort, for each unvisited vertex, recursively call DFS and then put the nodes in a stack. 
- To find if edit distance was one, without the whole DP soultion: if difference in string lens is greater than 1. if two chars dont match, delete one character from the longer string, or increment the index in that string. if lengths are equal then increment both index. 
- External sorting typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.
- For data bases, normalization is basically rearranging tables to remove duplicate data. Denormalization will duplicate data but will reduce look up times, plus will add complexity to keep duplicate data in sync [using constraints]. 
- Inner Join where only common key values are used, Outer Join where all values are included. 

Other interesting questions:
- To find median of two sorted arrays, compare the two medians and drop half each from both arrays and repeat.
- To find a target sum in an array, sort the array, set pointers to start and end and move them closer to each other.  
- To find a subarray with a target sum, keep two pointers, i, j. increment j when current sum < target and increment i otherwise. 
- Longest consecutive sequence: [100, 4, 200, 1, 3, 2] => 4. Create a hash table and then walk it [removing the elements checked] to track the longest consecutive sequence. Once the hash is created check which ones are in sequence. 
- Longest substring with unique chars, move two pointers in the string using hash. when end finds a character not already visited [using hash] set start to that position+1. keep max (max, end-start). 
- Similar solution for  "the longest substring with k unique characters ". Basically use a sliding window and a hash table to find solutions in O(n) time. 
- "Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n)." has a very similar solution. Use a window and a hash table. 
- Majority Vote Algorithm: Find out if any element exists more than n/2 times in an array of n elements. http://www.cs.utexas.edu/~moore/best-ideas/mjrty/. Keep a counter and a candidate. If the counter is 0, update the cand=str[i]; counter=1; if (counter != 0 ) if (str[i]==candidate) counter++, else counter--; the last value of the candidate is majority element candidate. You need step 2 to walk the array again and count the occurences of the candidate to check if its really the majority element.  
- Candy Distribution Problem: Walk the array left to right to find ascending ratings and then back from right to left to find ascending ratings. http://www.programcreek.com/2014/03/leetcode-candy-java/
- Construct a binary tree from inorder and preorder. for each node in pre order, the index of this element in the inorder is such that all elements before exist in the left subtree and all index after exist in the right sub tree. So recursiely:  tNode->left = buildTree(in, pre, inStrt, inIndex-1);
  tNode->right = buildTree(in, pre, inIndex+1, inEnd);
- Minimum depth of a Tree: Go BFS, keep the count at each level, return the count when you first hit a leaf. http://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/
- Max Path Sum in a Binary Tree: sometimes you need an additional max/min value on top of what the recursion returns. http://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/
- Total numbers of Binary trees with nodes 1-n = Catalan Number[n] = Summation from i = 1 to n = T(i-1) + T(n-i);
- Backtracking structure for all problems:
isSafe function which check for constraints for moves. 
FindX () {
if (target achieved) then return true;

For all possible next moves {
if (move is safe) {
 add move into solution. 
 if(FindX (next move) == true)
   return true;
 remove move from solution
}
return false;
}
- Merge two sorted linked lists. Very similar to how you would merge two sorted arrays. Start with a dummy node, pick lesser element of the two lists and add to dummy->next. Return dummy->next; 
- To remove the loop from a linked list, start ptr1 from the head, start ptr2 from any of the loop nodes. Now run ptr2 in the loop and check if ptr2->next is ptr1 or loop_node itself. After every such iteration proceed ptr1. The first time the ptr2->next is ptr1, you found the beginning of the loop. set ptr2->next = NULL to break the loop. 
- Fact: inorder and (one of)preorder/postorder uniquely identify a binary tree. To find if a tree is a subtree of another tree, compare the two traversals of the two trees. 
- isPowerOfTwo(int n) {return n>0 && (n&n-1)==0;}
- If you use static variable to simplify a recursion solution (or otherwise), point out that two separate calls to this function can mess up the whole solution. 
- Product of 3 numbers, if you sort the numbers the max product is  max(a[N-1]*a[0]*a[1], a[N-1]*a[N-2]*a[N-3]). This because you have to consider two negative numbers with very high absolute value. 
- Overlapping Rectangles: its easy to check if the rectangles do not overlap. Check left x coordinate is on the lest side of x coordinate of the other rectangle or vice versa. Similarily check if one rectangle is on the top of the other rectangle. 
- Finding median of a stream of numbers: Keep a max heap for numbers less than the current median, Keep a min heap to keep numbers greater than current mean. If both heaps have equal number of items, median is the average of the two roots, otherwise median is the root of the heap with more number of elements. 
- Finding mode: kinda complicated, but increment arr[arr[i]%k] by k. Since all numbers are less than k, the number at index i will be greatest if i is the most repeated character. 
- Similar approach can be used to find all repeating elements in an array if the range is known 0-k. make the element a negative number using the value as the index. When you hit a negative number you know that you have seen that value before and thats why the number at this index is negative. So you find a repeating element, print it. 
traverse the list for i= 0 to n-1 elements
{
  check for sign of A[abs(A[i])] ;
  if positive then
     make it negative by   A[abs(A[i])]=-A[abs(A[i])];
  else  // i.e., A[abs(A[i])] is negative
     this   element (ith element of list) is a repetition
}
- For C code, represent graphs using Adjacency matrix. int Graph [V][V];
- Very interesting question: Covnert binary tree to BST keeping the same tree structure. Walk the binary tree in some order and put elements in an array. Now sort this array. Now walk the tree in inorder and update value of the elements from the sorted array. 
- Problems like adding characters to make a string a palindrome, or the coin game where you pick a coin from either side you use subproblems of the type, i+1, j-1. So in this cases, you fill up the DP array in diagonal fashion. 
Basically going from the diagonal to the right top corner which gives you the result at DP[0][n]. 
- When considering data structures to use, dont forget about heaps as well as balanced BSTs. This might take extra space but sometimes helps to solve a problem. 
- Adding two numbers represented in a linked list is interesting if the numbers were not stored in reverse order. In that case, one solution would be to put the list in a stack and then add them up. Although not very interesting then. 
Its interesting when you cannot use extra space of a stack, so you use recursion to add them up. http://www.geeksforgeeks.org/sum-of-two-linked-lists/
- When you are shuffling an array, you find one position from the array and then swap it with the last element in the array and then repeat this for array 0-n-1 and so on.
- Another very interesting problem is to find out how many rooms you would need to schedule a certain number of meetings. You basically sort the start time array and then sort the end time array. Now you basically merge sort these two arrays. If the next smallest number is another start time, rooms_needed++. track the max here. When the next smallest item is from the end/departure then you reduce the rooms_needed.  http://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/
- To find all palindromic strings in a given string, walk the string and for each character, check if its at center of a palindrome. Careful with palindrones of EVEN LENGTH.
- Multiplying two numbers represented as strings is not tricky but interesting approach is to keep an integer array where you update the result in reverse order. It was getting difficult to implement without that. Check out the approach at: http://qa.geeksforgeeks.org/3748/multiply-large-numbers-as-strings
-  BST to sorted DLL -> bst_to_dll.c
- Mulitplication of two numbers: http://qa.geeksforgeeks.org/3748/multiply-large-numbers-as-strings
- Sorted circular list: Use Head ptr to the least node. Handle three cases: 1. Empty list 2. number smaller than Head. 3. everything else. 
- Equilibrium Sum: at index i leftsum==rightsum; walk once to get sum of all numbers. now walk again while reducing sum and increasing leftsum and check when leftsum == sum; 
- Roman to Integer. http://qa.geeksforgeeks.org/847/program-for-roman-numerals
- kth smallest element: you can enhance the BST by storing the number of nodes in the left subtree: http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/
- Merging Intervals: Treat the intervals as struct with begin time and end time. Now sort the intervals based on their start time. Walk the array of intervals. Push the first one on the stack. If the end of the top element is greater than the start of the next element, then there is an overlap, update the end of the top to max(top.end, item.end) if there is no overlap just put it on the stack. As an optimization, you can avoid using the stack and do these merges by simply walking the elements. 
- Flatten out a recursive linked list can be reduced to a BFS problem. flatten*.c
- Find a subarray with target sum is an interesting question already, but gets even better when array could have negative numbers. http://www.geeksforgeeks.org/find-subarray-with-given-sum-in-array-of-integers/
- Interesting O(n) solution for the celebrity problem: a = 0; b=n-1; while (a<b) { if(M[a][b]) {a++;} else {b--;} } if a knows b then a is not a celebrity, if a does not know b, then b cannot be a celebrity. at the end verify that a/b is the celebrity indeed. 
- Vertical Sum of binary tree put into a DLL: good question, asked at A9. http://www.geeksforgeeks.org/vertical-sum-in-binary-tree-set-space-optimized/
- Serializing and Deserializing Binary Tree: 1. For BST -> only preorder. 2. For ohter binary trees: either save both preorder and inroder OR save a marker [-1 ?] to mark NULL nodes and save only preorder. http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/
- Max points on the same line: For each point, find out the slope with each other point. Points with the same slope are on the same line. Now sort the slopes and find out how many are the same. Repeat this for each point and maintain the maximum. 




- Techniques of Better than Brute Force 
	- Try to see if using a hash table is feasible. That increases the space complexity by O(n) but the insert and lookups could be O(1) reducing the overall time complexity. 
- In computer science, ACID (Atomicity, Consistency, Isolation, Durability) is a set of properties of database transactions. In the context of databases, a single logical operation on the data is called a transaction. For example, a transfer of funds from one bank account to another, even involving multiple changes such as debiting one account and crediting another, is a single transaction.

Practice again: 
1. Write a method that returns all subsets of a set. Power set. 
2. 8.4 Write a method to compute all permutations of a string. http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/
3. Definitely go over Merge Sort and Quick Sort again. 
4. aligned_malloc and aligned_free() implementation. void *aligned_malloc(size_t bytes, size_t alignment); void aligned_free(void *p );
5. Find an element from rotated sorted array.
6. Recursive solution to find minimum number of characters to add to make a string a palindrome. Interesting problem: look at: http://www.geeksforgeeks.org/dynamic-programming-set-28-minimum-insertions-to-form-a-palindrome/
7. Create a DLL out of a linked list. The idea is to recurse the left subtree and then the for the rightmost node in this left subtree, put root node on the right of it. Now for the right subtree, go to the left most node and then put root on the left of it. Return root. This implementation is by not using static variable. Using the static variable is a simpler solution but is not thread safe. @convert_bst_to_dll.c.
8. Longest Palindromic subsequence. 
9. Implement a lockless queue with consumer/producer.  

OS Concepts:
- Copy-on-Write (COW) allows both parent and child processes to initially share the same pages in memory.

MIT LECTURES:

Dynamic Programming Questions: 
1. Edit distance: either add a character, remove a character or replace a character. If i=0, dp[i][j]=j, if j=0 dp[i][j]=i, if str1[i]==str[j] dp[i][j]=dp[i-1][j-1], else 1+min (DP[i-1][j], dp[i][j-1], dp[i-1][j-1])
2. Longest palindrome subsequence. for string length 1, return 1. for length 2, if chars match return 2. if str[l]==str[h] then return 2+lps(str, l+1, h-1) else return max lps(str, l+1, h),lps(str, l-1, h). http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/
3. Egg Drop Puzzle: http://www.geeksforgeeks.org/dynamic-programming-set-11-egg-dropping-puzzle/
4. Longest Common Subsequence: http://www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/
5. Longest Common Substring: http://www.geeksforgeeks.org/longest-common-substring/
6. Longest increasing subsequence: http://www.geeksforgeeks.org/dynamic-programming-set-3-longest-increasing-subsequence/
7. Longest palindrome substring: http://www.geeksforgeeks.org/longest-palindrome-substring-set-1/
8. Polygon Triangulation: http://www.geeksforgeeks.org/minimum-cost-polygon-triangulation/
9. 


Subproblems for Strings: 




NOTES:
Come back to Recursion chapter. Skipping Now. 
Learn Suffix Tree.

Sorting:
- Merge Sort: split at half, recursive for first half, second half and then merge. merge is just simply picking up the smaller one using auxillary space. 
- Quick Sort: partition at some pivot point. find the i where the pivot should be placed and then swap. 

---------------------
Other Hard Problems:
---------------------
1. Find if a given string can be represented from a substring by iterating the substring “n” times. 
http://www.geeksforgeeks.org/find-given-string-can-represented-substring-iterating-substring-n-times/

----------------------
Interviews:
----------------------

06/11: Microsoft Online Technical Screen for Azure Networking Team:
1. String given with phone numbers in format yyyxxxzzz or yyy-xxx-zzzz, reformat them to be xxx-yyy-zzzz. Use minimal extra storage.
2. String array given with codes. each code has a priority 1,2,3. Sort the array of codes in order or priority, within the same priority order is not important. 
3. Explain what Mystery function does, basically a class with person P and his aquaintances. this mystery function will put all aquaintances on a stack, then pop one out and then pushes its aquaintances on the stack. If the same initial name is found on the stack, then the function returns true. If the stack is emptied out the function returns false. 

Riverbed: 
07/01: Phone interview: Given a linked list, you have to first split even odd places and then reverse odd list and then merge sort the two. 
07/08: 
1. Clone a linked list with random pointers. 
2. producer/consumer queue, deadlock, multithreading barrier etc. 
3. Delete a node from linked list 
4. Bucket sort. sort a list of phone numbers. all 10 digit numbers. 

Facebook:
07/11: 
Phone:
1. most challenging project. 
2. move all zeroes to the end of the array. http://www.geeksforgeeks.org/move-zeroes-end-array/
3. merge k sorted arrays. http://www.geeksforgeeks.org/merge-k-sorted-arrays/
- Result - Need a second phone interview. 

07/18: Second phone interview:
1. http://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/
2. Optimize the above, ask complexities etc. 

07/29: 
Onsite:
#1 Culture and Coding
- Traits of a good manager/bad manager. 
- Career goals 
- How do you use Facebook?
- One annoying thing about FB. 
- Coding: Given 5 arrays of integers, find in parallel the maximum across all arrays. I spawned one thread to handle each array and then walk the result array to find the maximum. 

#2
- How to count 1s in a integer. 
- How to optimize for millions of these countOnes call. Basically keep a hash with count of ones for each one byte number and then call it 8 times for each integer. 
- Find k closest points to origin. 

Lunch with Matt

#3 System Design - Rituraj
- Design a system of updating comments on stories on news feed. 

#4 Coding
- Find number in a rotated sorted array. 
- Given sequence of tasks and cold time find total time. t1t2t1t2, 2 => t1 t2 _ t1 t2 => 5.
- Question on finding shortest time if sequence is not important [no coding]

#5 Coding
- Insert a node to a directed graph. 
- Find shortest path between two points. 
 
Second Design Onsite Interview: 08/08
- Get k nearest points given a point. k-d tree problem


Google: 
07/12:
Phone interview:
1. Evaluate a polynomial. f(x)=3x2 + 2x + 3, f(n) = ?. Do without using power function, just go in a loop of power number and multiplying x to it.  
2. pack a string []. Couldnt suggest escape sequence. 
Second Phone interview: 07/25:
1. Design two APIs. Addpoint (arr, x, y) and then Get_k_closest_points (arr, x, y). I provided solution where a heap is created for the given point x,y every time Get_k is called. 
Rejected.

07/13: Linkedin Phone:
First hour: behavioral and resume based questions. ideal engineer etc. 
Second hour:
1. string with digits and characters, get the sum of all numbers formed in a string. 123?sdfh77 => 200
2. Interval Tree question  http://www.geeksforgeeks.org/interval-tree/. 

08/04: Linkedin Onsite:
#1. describe your project on the board. consistent hashing
#2. Design a sliding window based getAvg and getValue APIs for stock prices. Updates with {name, price}
#3. Provide AddDrop(double center_of_the_drop) and isWalkwayWet() APIs for rain drops. Interval tree, merging overlapping intervals. 
#4. merge k sorted linked lists. find second smallest number in a tournament tree. Root of the tournament tree is the minimum element in the tree. 
#5. design url shortening service. concurrent hashing.
#6. Design a pub sub model with some specific constraints. concurrent hashing. 


07/20: A9 Phone:
1. Given an expression calculate the value (2*3)/(5+6). Store in some data structure and evaluate the expression. 
2. Described projects. 

09/01 Uber Onsite: 555 Market Street
#1. Implement Task Queue for Uber trip reservation. Discussion around granulated locks.
#2. Design system with multiple tiers and calculating data loss percentage. Every tier keeps list of holes and passes this to the next tier. The last tier merges all and finds data loss. 
#3. Hiring Manager, introductions. 
#4. Behavioral round, biggest failure, conflict with colleague, why Uber. 
#5. Interator for recursive list, H20 problem. 
http://massivetechinterview.blogspot.com/2015/11/linkedin-h2o.html


09/07 Cask Phone Interview:
#1. Project work / Experience
#2. Move all target numbers to the end of an array. 
#3. Discussion around Java and C comparisons. 


09/09 Cloudera Phone Interview:
#1. Project  / Experience
#2. Implement Circular Buffer. A queue using a fixed size array.  

09/14: Cask Data Onsite: 2pm-6pm.
#1. Given k sorted lists, find the minimum range that covers all lists. https://www.careercup.com/question?id=16759664
#2. Project Description and discussions
#3. Given k iterators for sorted streams, write an iterator over all of the given iterators. Basically merge k sorted lists. 
#4. Mgr Interview, heartbeat related design question and project discussions. 

09/23: MapR phone interview
There was another interview of 30 mins with the hiring manager, this was the second one for an hour with engineer. 
- First 30 mins about my experience and corss questioning
- Implement printdivision(int num, int den) -> 1/3 = 0.3[0] so only print the repeating sequence once and then in the bracket print which index it starts from. Used a hash for remainders. 

09/26: Cloudera Onsite
#1 Experience. Fibonacci, optimize for constant memory. Security related questions, that I couldnt answer. hit browser what happens. 
#2 Experience, discussions around it. How many DVRs required for recording programs that can overlap. The train-platform problem. 
#3 Circular Buffer using array, handle full/empty using conditional variables. {(I believe) This guy dissed me for not using two seperate cond variables.  } http://stackoverflow.com/questions/4062126/can-2-pthread-condition-variables-share-the-same-mutex
#4 Manager lunch, behavioral. Why did you leave Cisco, example of initiative, leadership roles etc.
#5 Count_bits (char *ptr, int size) count all set bits from ptr to size bytes. Design system with thermostat updating temperature that app reads. Up/Down temperature from app. 

Got a reject on 9/28. Feedback: With only one position open, they want someone stronger/better experience in: Java, Database concepts, concurrency, RPC, REST.

09/30: 
Phone interview with Manager from Apache Drill Team. 
- Discussed projects etc. 
- How do you find top n most frequently occuring URLs from a very big file consisting URLs. Could not answer this completely. Use consistent hashing to split the URLs into multiple hash tables. 

Notes on other Questions:
1. Tower of Hanoi Problem:
In each case, a total of 2n-1 moves are made.
Just repeat steps based on number of disks. 
 
For an even number of disks:
make the legal move between pegs A and B
make the legal move between pegs A and C
make the legal move between pegs B and C
repeat until complete

For an odd number of disks:
make the legal move between pegs A and C
make the legal move between pegs A and B
make the legal move between pegs C and B
repeat until complete



Design Questions Notes:
Steps from Hiredtech Article: http://www.hiredintech.com/system-design/the-system-design-process/
1. Gather requirements, system constraints, scope of the the system, 
-
 

Send closure emails to 
- Juniper and Riverbed. 

OFFER Negotiation Notes:
- In the negotiation class, we did an exercise where we had to rate ourselves on how we think we did on the negotiation. 
From my Cask offer negotiation, I would rate myself at ~6/10. 

Good Things I did: 
1. They anchored the stocks at very low amount at 30k, which I reanchored at 130k at 0.2% of the company. 

BAD BAD things I did:
1. I DID NOT AIM HIGH. This I think has been my problem quite a lot. I was prepared to take 100k options and 190k going into the discussion.
2. I DID NOT prepare enough. If I was to accept 190k and 100k options, I SHOULD have accepted while adding another dimension to the offer. 
More so because I have been burnt with this once at PAN. I SHOULD have asked a committment of this years bonus as a side thing before accepting the offer. 

USE THIS NEXT TIME:
1. AIM HIGH !!!
2. DO NOT BUY INTO THEIR ANCHOR. SET YOUR OWN ANCHOR. 
3. PREPARE A LOT BEFORE GOING INTO THE CALL. 
4. BEFORE AGREEING ALWAYS KEEP SOME SIDEKICK READY. 
I did not think about what I would
 
